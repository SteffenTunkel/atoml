    @Test(timeout=21600000)
    public void test_<<<NAME>>>_<<<DATASET>>>() throws Exception {
        for(int iter=1; iter<=<<<ITERATIONS>>>; iter++) {
            Instances data = loadData("/morphdata/<<<DATASET>>>_" + iter + ".arff");
            Instances morphedData = loadData("/morphdata/<<<DATASET>>>_" + iter + "_<<<NAME>>>.arff");

            Clusterer clusterer = AbstractClusterer.forName("<<<PACKAGENAME>>>.<<<CLASSIFIER>>>", Arrays.copyOf(parameters, parameters.length));
		    clusterer.buildClusterer(data);
            Clusterer morphedClusterer = AbstractClusterer.forName("<<<PACKAGENAME>>>.<<<CLASSIFIER>>>", Arrays.copyOf(parameters, parameters.length));
            morphedClusterer.buildClusterer(morphedData);

            int deviationsCounts = 0;
            int softScoresCount = 0;
            double[] deviationVector = new double[data.size()];
            double[] expectedMorphDistributions = new double[data.size()];
            double[] morphedDistributions = new double[data.size()];
            HashMap<Integer, HashSet<Integer>> expectedClustersMap = createClusterMap(clusterer.numberOfClusters());
            HashMap<Integer, HashSet<Integer>> morphedClustersMap = createClusterMap(morphedClusterer.numberOfClusters());
            for (int i = 0; i < data.size(); i++) {
                double originalCluster = clusterer.clusterInstance(data.instance(i));
                double expectedMorphedCluster = originalCluster;
                expectedClustersMap.get((int) expectedMorphedCluster).add(i);
                expectedMorphDistributions[i] = clusterer.distributionForInstance(data.instance(i))[(int) originalCluster];
                double morphedCluster = morphedClusterer.clusterInstance(data.instance(i));
                morphedClustersMap.get((int) morphedCluster).add(i);
                morphedDistributions[i] = morphedClusterer.distributionForInstance(data.instance(i))[(int) morphedCluster];
                if ( (expectedMorphDistributions[i] > 0.0 && expectedMorphDistributions[i] < 1.0) || (morphedDistributions[i] > 0.0 && morphedDistributions[i] < 1.0) ) {
                    softScoresCount++;
                }
            }
            morphedClustersMap = flipSameClusters(expectedClustersMap, morphedClustersMap);
            for (int i = 0; i < data.size(); i++) {
                for (int j = 0; j < expectedClustersMap.size(); j++) {
                    if (expectedClustersMap.get(j).contains(i)) {
                        if (morphedClustersMap.containsKey(j) && morphedClustersMap.get(j).contains(i)) {
                            deviationVector[i] = 0;
                            break;
                        } else {
                            deviationsCounts++;
                            deviationVector[i] = 1;
                            break;
                        }
                    }
                }
            }

            //score-matching for soft clustering
            int deviationsScores = 0;
            HashMap<Integer, ArrayList<Double>> expectedScoresMap = new HashMap<>();
            HashMap<Integer, ArrayList<Double>> morphedScoresMap = new HashMap<>();
            if (softScoresCount > 0) {
                expectedScoresMap = createScoresMap(expectedClustersMap, expectedMorphDistributions);
                morphedScoresMap = createScoresMap(morphedClustersMap, morphedDistributions);
                for (Integer cluster: expectedScoresMap.keySet()) {
                    if (morphedScoresMap.containsKey(cluster)) {
                        for (int i = 0; i < expectedScoresMap.get(cluster).size(); i++) {
                            if (i < morphedScoresMap.get(cluster).size()) {
                                if (!(Double.compare(expectedScoresMap.get(cluster).get(i), morphedScoresMap.get(cluster).get(i)) == 0)) {
                                    deviationsScores++;
                                }
                            } else {
                                deviationsScores++;
                            }
                        }
                    } else {
                        deviationsScores += expectedScoresMap.get(cluster).size();
                    }
                }
            }

            String nameWithoutParams = testname.getMethodName().split("\\\\[")[0];
             <<<MYSQLEVALMORPH>>>assertMorphTest(<<<EVALUATIONTYPE>>>, nameWithoutParams, iter, data.size(), deviationsCounts, deviationVector, deviationsScores, expectedScoresMap, morphedScoresMap);
        }
    }

