import unittest
import xmlrunner
import pandas as pd
import numpy as np
import threading
import functools
import inspect
import math
import traceback

from parameterized import parameterized
from scipy.io.arff import loadarff
from scipy.stats import chisquare, ks_2samp
from sklearn.preprocessing import LabelEncoder
<<<IMPORTCLASSIFIER>>>

### SQL PART
import sqlalchemy as db

db_connection_str = 'mysql+pymysql://atoml:atoml@127.0.0.1:3306/atoml'
db_connection = db.create_engine(db_connection_str)

metadata = db.MetaData()

db_results_morph = db.Table('results_morphtests', metadata,
    db.Column('id', db.Integer()),
    db.Column('algorithm', db.String(200), nullable=False),
    db.Column('parameters', db.String(200), default=None),
    db.Column('testcase', db.String(200), default=None),
    db.Column('iteration', db.Integer(), default=None),
    db.Column('testsize', db.Integer(), default=None),
    db.Column('deviations_counts', db.Integer(), default=None),
    db.Column('deviations_scores', db.Integer(), default=None),
    db.Column('pval_counts', db.Float(), default=None),
    db.Column('pval_scores', db.Float(), default=None),
    db.Column('passed_exact_score', db.Integer(), default=None),
    db.Column('passed_exact_class', db.Integer(), default=None),
    db.Column('passed_stat_class', db.Integer(), default=None),
    db.Column('passed_stat_score', db.Integer(), default=None))
    
db_results_smoke = db.Table('results_smoketests', metadata,
    db.Column('id', db.Integer()),
    db.Column('algorithm', db.String(200), nullable=False),
    db.Column('parameters', db.String(200), default=None),
    db.Column('testcase', db.String(200), default=None),
    db.Column('iteration', db.Integer(), default=None),
    db.Column('passed', db.Integer(), default=None),
    db.Column('exception', db.String(200), default=None),
    db.Column('message', db.String(1000), default=None),
    db.Column('stacktrace', db.Text(), default=None))

def write_morph_to_db(results_dict):
    insert_statement = db.insert(db_results_morph).values(**results_dict)
    db_connection.execute(insert_statement)
    
def write_smoke_to_db(results_dict):
    insert_statement = db.insert(db_results_smoke).values(**results_dict)
    db_connection.execute(insert_statement)
### SQL PART


class TestTimeoutException(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

# thanks to https://gist.github.com/vadimg/2902788
def timeout(duration, default=None):
    def decorator(func):
        class InterruptableThread(threading.Thread):
            def __init__(self, args, kwargs):
                threading.Thread.__init__(self)
                self.args = args
                self.kwargs = kwargs
                self.result = default
                self.daemon = True
                self.exception = None

            def run(self):
                try:
                    self.result = func(*self.args, **self.kwargs)
                except Exception as e:
                    self.exception = e

        @functools.wraps(func)
        def wrap(*args, **kwargs):
            it = InterruptableThread(args, kwargs)
            it.start()
            it.join(duration)
            if it.isAlive():
                raise TestTimeoutException('timeout after %i seconds for test %s' % (duration, func))
            if it.exception:
                raise it.exception
            return it.result
        return wrap
    return decorator

class <<<CLASSNAME>>>(unittest.TestCase):

<<<HYPERPARAMETERS>>>

<<<METHODS>>>

if __name__ == '__main__':
    unittest.main()
#    with open('results.xml', 'wb') as output:
#        unittest.main(
#            testRunner=xmlrunner.XMLTestRunner(output=output),
#            failfast=False, buffer=False, catchbreak=False)